
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FMG Utilities Validation Framework Documentation</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
    </style>
</head>
<body>
    <h1>FMG Utilities Validation Framework Documentation</h1>

    <p>This document provides an overview of the FMG Utilities Validation Framework, detailing its classes, methods, and key functionalities.</p>

    <h2>Table of Contents</h2>

    <ul>
        <li><a href="#validatorprovider">ValidatorProvider</a></li>
        <li><a href="#ivalidator-and-ivalidatort">IValidator and IValidator&lt;T></a></li>
        <li><a href="#validatort">Validator&lt;T></a></li>
        <li><a href="#validationresult">ValidationResult</a></li>
        <li><a href="#extensions">Extensions</a></li>
        <li><a href="#validationexception">ValidationException</a></li>
        <li><a href="#attribute-based-validation-classes">Attribute-based Validation Classes</a></li>
        <li><a href="#fluent-validation-classes">Fluent Validation Classes</a></li>
    </ul>

    <h2>ValidatorProvider</h2>

    <ul>
        <li><strong>Constructor</strong>: Initializes the provider and loads validators.</li>
        <li><strong>GetValidators&lt;T></strong>: Retrieves validators for a given type.</li>
    </ul>

    <h2>IValidator and IValidator&lt;T></h2>

    <ul>
        <li><strong>Validate</strong>: Synchronously validates an instance.</li>
        <li><strong>ValidateAsync</strong>: Asynchronously validates an instance.</li>
    </ul>

    <h2>Validator&lt;T></h2>

    <ul>
        <li><strong>Validate</strong>: Validates an instance with optional property validation.</li>
        <li><strong>ValidateAsync</strong>: Asynchronously validates an instance.</li>
        <li><strong>ValidateProperty</strong>: Validates a single property.</li>
        <li><strong>ValidateAll</strong>: Validates multiple validation results.</li>
        <li><strong>Required</strong>: Checks if a property is not null.</li>
        <li><strong>ValidateRange</strong>: Validates if a property is within a specified range.</li>
        <li><strong>ValidateRegex</strong>: Validates if a property matches a regex pattern.</li>
        <li><strong>ValidateWithCustomMethod</strong>: Validates a property with a custom validation method.</li>
    </ul>

    <h2>ValidationResult</h2>

    <ul>
        <li><strong>IsValid</strong>: Indicates if the validation was successful.</li>
        <li><strong>Errors</strong>: Contains validation error messages.</li>
        <li><strong>Merge</strong>: Merges multiple ValidationResult instances.</li>
    </ul>

    <h2>Extensions</h2>

    <p>Provides extension methods for common validation scenarios, such as range checks and regex matches.</p>

    <h2>ValidationException</h2>

    <p>Represents errors that occur during validation.</p>

    <h2>Attribute-based Validation Classes</h2>

    <h3>Property Validation Attributes</h3>

    <ul>
        <li><strong>DateRangeAttribute</strong></li>
        <li><strong>EmailAttribute</strong></li>
        <li><strong>IsNotEmptyAttribute</strong></li>
        <li><strong>LengthAttribute</strong></li>
        <li><strong>MaxLengthAttribute</strong></li>
        <li><strong>MinLengthAttribute</strong></li>
        <li><strong>NotNullAttribute</strong></li>
        <li><strong>PasswordFormatAttribute</strong></li>
        <li><strong>RangeAttribute</strong></li>
        <li><strong>RegularExpressionAttribute</strong></li>
        <li><strong>RequiredAttribute</strong></li>
        <li><strong>TimeSpanRangeAttribute</strong></li>
        <li><strong>UrlAttribute</strong></li>
        <li><strong>UsernameFormatAttribute</strong></li>
    </ul>

    <p>Each attribute class extends <code>PropertyValidationAttribute</code> and overrides the <code>IsValid</code> method to implement specific validation logic.</p>

    <h2>Fluent Validation Classes</h2>

    <h3>FluentValidatorBuilder&lt;T></h3>

    <ul>
        <li><strong>RuleFor</strong>: Adds a validation rule for a specific property.</li>
        <li><strong>WithMessage</strong>: Specifies a custom error message for the last rule added.</li>
        <li><strong>Build</strong>: Creates an <code>IValidator&lt;T&gt;</code> instance with the defined rules.</li>
    </ul>

    <h3>InlineValidator&lt;T></h3>

    <p>Implements custom validation logic defined via the fluent API.</p>

    <hr />

    <p>This document provides a high-level overview of the components within the FMG Utilities Validation Framework. For detailed usage and examples, refer to the specific class and method documentation within the codebase.</p>


    <h2>Usage and Samples</h2>

    <p>This section provides examples on how to use the FMG Utilities Validation Framework in practical scenarios.</p>

    <h3>Defining a Validator</h3>

<pre><code>public class PlayerValidator : Validator&lt;Player&gt;
{
    public static readonly DateTime MinBorn = new(1990, 1, 1);
    public static readonly DateTime MaxBorn = new(2023, 1, 1);

    public override ValidationResult Validate(Player instance)
    {
        var nameValidation = Required(instance.Name, nameof(instance.Name));
        var ageValidation = ValidateRange(instance.Age, 10, 20, nameof(instance.Name));
        var emailValidation = string.IsNullOrEmpty(instance.Name) ?
            ValidationResult.Failed :
            instance.Name.IsEmail();
        var bornValidation = instance.Born.IsInRange(MinBorn, MaxBorn) ?
            ValidationResult.Ok :
            ValidationResult.Failed;

        return ValidateAll(nameValidation, ageValidation, emailValidation, bornValidation);
    }
}
</code></pre>

    <h3>Manual Validation</h3>

<pre><code>public void Validate_Manually()
{
    var player = new Player
    {
        Name = "Nick",
        Email = "Test@Google.com",
        Age = 20,
        Born = new DateTime(2020, 1, 1)
    };

    var validator = new PlayerValidator();
    var validationResult = validator.Validate(player);

    if (validationResult.IsValid)
    {
        // do somethings ...
    }
    else
    {
        Debug.Log(validationResult.Errors);
    }
}
</code></pre>

    <h3>Fluent Validation</h3>

<pre><code>public void Validate_Manually_Fluent()
{
    var player = new Player
    {
        Name = "Nick",
        Email = "Test@Google.com",
        Age = 20,
        Born = new DateTime(2020, 1, 1)
    };

    var validationResult = ValidatorProvider.For&lt;Player&gt;()
        .RuleFor(x => x.Name, name => !string.IsNullOrWhiteSpace(name), "Name is required")
        .RuleFor(x => x.Age, age => age &gt; 18, "Must be over 18")
        .WithMessage("Age requirement not met")
        .Build()
        .Validate(player);

    if (validationResult.IsValid)
    {
        // do somethings ...
    }
    else
    {
        Debug.Log(validationResult.Errors);
    }
}
</code></pre>

    <h3>Using ValidatorProvider</h3>

<pre><code>public void Validate_Via_ValidatorProvider()
{
    var player = new Player
    {
        Name = "Nick",
        Email = "Test@Google.com",
        Age = 20,
        Born = new DateTime(2020, 1, 1)
    };

    var validationResult = ValidatorProvider.Validate(player, typeof(PlayerValidator));

    if (validationResult.IsValid)
    {
        // do somethings ...
    }
    else
    {
        Debug.Log(validationResult.Errors);
    }
}
</code></pre>

    <h3>Validator Attributes</h3>

    <pre><code>
    [Validator(typeof(StudentValidator1))]
    [Validator(typeof(StudentValidator2))]
    public class Student
    {
        public string Name { get; set; }
        public string Email { get; set; }
        public int Age { get; set; }
        public DateTime Born { get; set; }
    }

    public class StudentValidator1 : Validator<Student>
    {
        public override ValidationResult Validate(Student instance)
        {
            var nameValidation = Required(instance.Name, nameof(instance.Name));

            var ageValidation = ValidateRange(instance.Age, 10, 20, nameof(instance.Name));

            var emailValidation = string.IsNullOrEmpty(instance.Name) ?
            ValidationResult.Failed :
            instance.Name.IsEmail();

            return ValidateAll(nameValidation, ageValidation, emailValidation);
        }
    }

    public class StudentValidator2 : Validator<Student>
    {
        public static readonly DateTime MinBorn = new(1990, 1, 1);
        public static readonly DateTime MaxBorn = new(2023, 1, 1);

        public override ValidationResult Validate(Student instance)
        {
            return instance.Born.IsInRange(MinBorn, MaxBorn) ?
            ValidationResult.Ok :
            ValidationResult.Failed;
        }
    }
</code></pre>

<pre><code>public void Validate_Via_ValidatorProvider_By_ValidatorAttribute()
{
    var student = new Student
    {
        Name = "Nick",
        Email = "Test@Google.com",
        Age = 20,
        Born = new DateTime(2020, 1, 1)
    };

    var validationResult = ValidatorProvider.Validate(student, false);

    if (validationResult.IsValid)
    {
        // do somethings ...
    }
    else
    {
        Debug.Log(validationResult.Errors);
    }
}
</code></pre>

    <h3>Property Validation Attributes</h3>

<pre><code>
    public class Customer
    {
        [Required]
        public string Name { get; set; }

        [Required]
        [Email]
        public string Email { get; set; }

        [Range(10, 20)]
        public int Age { get; set; }

        [DateRange("1990-01-01", "2023-01-01")]
        public DateTime Born { get; set; }
    }
</code></pre>

<pre><code>public void Validate_Via_ValidatorProvider_By_PropertyAttribute()
{
    var customer = new Customer
    {
        Name = "Nick",
        Email = "Test@Google.com",
        Age = 20,
        Born = new DateTime(2020, 1, 1)
    };

    var validationResult = ValidatorProvider.Validate(customer);

    if (validationResult.IsValid)
    {
        // do somethings ...
    }
    else
    {
        Debug.Log(validationResult.Errors);
    }
}
</code></pre>

</body>
</html>
